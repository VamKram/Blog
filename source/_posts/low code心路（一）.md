---
title: Low Code ä¹‹è·¯ï¼ˆä¸€ï¼‰
date: 2020/12/15
cover: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=962309492,3418279211&fm=26&gp=0.jpg
categories:
- LowCode
tags: 
- form

---
# Low Code ä¹‹è·¯ï¼ˆä¸€ï¼‰

## èƒŒæ™¯

20å¹´è¦åšä¸€äº›æ–°çš„äº‹æƒ…ï¼Œç»ˆäºå¯ä»¥è„±ç¦»ç¹å¤çš„ä¸šåŠ¡é€»è¾‘ï¼Œä¸»å¯¼ä¸€äº›æ›´åŠ æœ‰è¶£çš„äº‹æƒ…ã€‚

å…ˆæ¥èŠä¸‹æˆ‘ä¹‹å‰è´Ÿè´£çš„ä¸šåŠ¡æµç¨‹æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå³ä¼ ç»Ÿçš„ä¸šåŠ¡æ˜¯å¦‚ä½•è¿›è¡Œçš„ã€‚

![image-20210327155304930](https://technologybook.tech/assets/img/image-20210327155304930.png)

å½“ç„¶è¿™ä¸€å¥—ç³»ç»Ÿè¿˜åŒ…å«å…¶ä»–çš„ä¸€äº›ç»†èŠ‚åŒ…æ‹¬é”™è¯¯é€šçŸ¥ï¼Œå¤„ç†æµç¨‹ç­‰å¤æ‚çš„å†…å®¹ï¼Œä½†å…¶æ ¸å¿ƒå°±å¦‚å›¾ç¤º

è¿™ç§æ–¹æ¡ˆçš„é—®é¢˜

- æ¯ä¸ªå›½å®¶å¯¹åº”ä¸€å¥—formå†å¯¹åº”ä¸€å¥—ä»£ç ï¼Œç»´æŠ¤æˆæœ¬é«˜
- æœåŠ¡ç«¯è¿”å›ä¹Ÿæ˜¯ä¸€ä¸€å¯¹åº”
- åŒä¸€ï¼Œå› ä¸ºä½¿é¢†é¦†å¸¸æœ‰å˜åŒ–ï¼Œç»´æŠ¤æˆæœ¬æ›´é«˜ï¼Œå‡ ä¹ä¸å¯å¤ç”¨ã€‚
- ä»£ç ç‹¬ç«‹æ€§å¤ªé«˜ï¼Œæ•…éšœç‡é«˜

æ‰€ä»¥ä»Šå¹´æˆ‘ä¸»è¦æŠ•å…¥åˆ°å¯¹è¿™ä¸ªæµç¨‹çš„ä¼˜åŒ–çš„å·¥ä½œä¸­æ¥ï¼Œ ä¸»è¦çš„å·¥ä½œå›´ç»•ç€ å»ºç«‹ä¸€ä¸ªé€šç”¨è¡¨å•ï¼Œ å»ºç«‹ä¸€ä¸ªé€šç”¨å¡«å†™è„šæœ¬ä¸¤ä¸ªæ–¹é¢æ¥è¿›è¡Œï¼Œç›®æ ‡å³ä½¿ï¼Œå°±éœ€è¦ç›¸åº”çš„é…ç½®æ–‡ä»¶ï¼Œä»»ä½•äººéƒ½å¯ä»¥åŸºäºé…ç½®æ–‡ä»¶è¿›è¡Œé…ç½®ï¼Œç®€å•çš„ä¿®æ”¹é…ç½®æ–‡ä»¶å°±èƒ½ç”Ÿæˆæ–°çš„è¡¨å•ï¼Œå’Œè§„å®šç›¸åº”çš„çˆ¬å–æµç¨‹æ¥å¯¹å†…å®¹è¿›è¡Œè·å–å’Œå¡«å……ã€‚

![image-20210327160340220](https://technologybook.tech/assets/img/image-20210327160340220.png)



### è°ƒç ”é˜¶æ®µ

#### å¸‚é¢ä¸Šçš„ç«å“

***Formily***

> Formily è§£å†³æ–¹æ¡ˆçš„æœ¬è´¨æ˜¯æ„é€ äº†ä¸€ä¸ª Observable Form Graphï¼Œåœ¨è¿™ä¸ª Form Graph ä¸­ï¼Œæˆ‘ä»¬æŠ½è±¡äº†æ•´ä¸ªè¡¨å•é¢†åŸŸæ¨¡å‹ï¼ŒåŒæ—¶è¿™ä¸ªæ¨¡å‹åˆæ˜¯ä¸€ä¸ªæ— é™å¾ªç¯çŠ¶æ€æœºã€‚

è¯»äº†ä¸‹ä»£ç ä¸»è¦æ˜¯åŸºäºRXçš„Observeable Form GraphçŠ¶æ€æœºï¼ŒåŸºæœ¬æ˜¯é€šè¿‡component typeæ‰¾åˆ°renderçš„å†…å®¹ï¼Œç„¶åé€šè¿‡ä¸€ä¸ªåŸºäºRx çš„ æ‰€è°“Form graphæ¥ç»´æŠ¤å…¨å±€çš„çŠ¶æ€ï¼Œè¯»JSON æ¥render Formè§†å›¾ç„¶åé€šè¿‡keyæ¥å»ºç«‹field relationï¼Œç„¶åç»´æŠ¤å…¨å±€çŠ¶æ€ï¼Œä¸»è¦çš„å·¥ä½œåœ¨å¯¹Form æ•°æ®ç»“æ„åŠæ•°æ®æ›´æ–°ç®—æ³•å’Œä¸€äº›æ€§èƒ½ä¼˜åŠ¿ï¼Œæå‡ºä¸€å¥—updater tree å’Œ path matchæ€§èƒ½ä¸é”™ï¼Œè€Œä¸”æ˜¯ç»è¿‡å¤§é‡ç”¨æˆ·éªŒè¯çš„ï¼ŒåŒ…æ‹¬é˜¿é‡Œå†…éƒ¨éªŒè¯çš„å¯é çš„åº“ã€‚

***Amis***

> amis æ˜¯ä¸€ä¸ªä½ä»£ç å‰ç«¯æ¡†æ¶ï¼Œå®ƒä½¿ç”¨ JSON é…ç½®æ¥ç”Ÿæˆé¡µé¢ï¼Œå¯ä»¥å‡å°‘é¡µé¢å¼€å‘å·¥ä½œé‡ï¼Œæå¤§æå‡æ•ˆç‡ã€‚

åˆå§‹åŒ–æ¥å£ï¼Œæ•°æ®é“¾çš„è®¾è®¡ï¼Œæ›´åå‘ä¸šåŠ¡ä¸€äº›ï¼ŒåŒ…æ‹¬è¡¨è¾¾å¼ï¼Œè”åŠ¨ï¼Œ rendereréƒ½è®©äººæ„Ÿåˆ°è¿™æ˜¯ä¸€ä¸ªå¾ˆreactiveçš„åº“ï¼Œç®€å•æ˜“ç”¨ï¼Œæºä»£ç æ²¡æœ‰çœ‹ï¼Œæƒ³æƒ³å¤§æ¦‚å·®ä¸å¤šã€‚

> æ¸²æŸ“è¿‡ç¨‹å°±æ˜¯æ ¹æ®èŠ‚ç‚¹ path ä¿¡æ¯ï¼Œè·Ÿç»„ä»¶æ± ä¸­çš„ç»„ä»¶ `test` (æ£€æµ‹) ä¿¡æ¯åšåŒ¹é…ï¼Œå¦‚æœå‘½ä¸­ï¼Œåˆ™æŠŠå½“å‰èŠ‚ç‚¹è½¬ç»™å¯¹åº”ç»„ä»¶æ¸²æŸ“ï¼ŒèŠ‚ç‚¹ä¸­å…¶ä»–å±æ€§å°†ä½œä¸ºç›®æ ‡ç»„ä»¶çš„ propsã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ˜¯å®¹å™¨ç»„ä»¶ï¼Œæ¯”å¦‚ä»¥ä¸Šä¾‹å­ä¸­çš„ `page` ç»„ä»¶ï¼Œä» props ä¸­æ‹¿åˆ°çš„ `body` æ˜¯ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œç”±äºèŠ‚ç‚¹ç±»å‹æ˜¯ä¸å›ºå®šï¼Œç”±ä½¿ç”¨è€…å†³å®šï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥å®Œæˆæ¸²æŸ“ï¼Œæ‰€ä»¥äº¤ç»™å±æ€§ä¸­ä¸‹å‘çš„ `render` æ–¹æ³•å»å®Œæˆæ¸²æŸ“ï¼Œ`{render('body', body)}`ï¼Œä»–çš„å·¥ä½œå°±æ˜¯æ‹¿å­èŠ‚ç‚¹çš„ path ä¿¡æ¯å»ç»„ä»¶æ± é‡Œé¢æ‰¾åˆ°å¯¹åº”çš„æ¸²æŸ“å™¨ï¼Œç„¶åäº¤ç»™å¯¹åº”ç»„ä»¶å»å®Œæˆæ¸²æŸ“

***FormRender***

> é€šè¿‡ JSON Schema ç”Ÿæˆæ ‡å‡† Formï¼Œå¸¸ç”¨äºè‡ªå®šä¹‰æ­å»ºé…ç½®ç•Œé¢ç”Ÿæˆ

å®ƒæä¾›ä¸€ä¸ª è¡¨å•è®¾è®¡å™¨ï¼Œå’ŒåŸºäºJSONçš„formcreateï¼Œæ–‡æ¡£å†™çš„ä¸æ˜¯å¾ˆå¥½ã€‚ã€‚ï¼Œä»£ç é‡Œä¹Ÿæ˜¯ç”¨global contextç»´æŠ¤çŠ¶æ€ï¼Œé€šè¿‡evalå®ç°è¡¨è¾¾å¼ï¼Œæ¯”è¾ƒçµæ´»ï¼Œæ”¯æŒå‡ ç§æ ‡å‡†ç±»å‹ï¼Œé€šè¿‡schema typeç±»å‹æ¥ç¡®å®šæ¸²æŸ“å†…å®¹è¿™ä¸ªæˆ‘ä¸æ˜¯å¾ˆä¸­æ„ï¼Œä¹Ÿæ”¯æŒè‡ªå®šä¹‰type componentï¼Œä½†æ˜¯ç›®å‰çœ‹bugæ¯”è¾ƒå¤šï¼Œæ›´æ–°ç­–ç•¥ä¹Ÿæ˜¯å…¨é‡æ›´æ–°ï¼Œæ²¡æœ‰ä¼˜åŒ–ï¼Œæ€§èƒ½å·®ä¸€äº›ã€‚

è¿˜æœ‰ä¸€äº›è¯¸å¦‚formcreatorç­‰ç­‰åº“ï¼Œæ–¹æ¡ˆéƒ½å¤§åŒå°å¼‚ï¼ŒåŒä¸€ä¸Šçš„è°ƒç ”ç¡®å®šäº†å‡ ç‚¹

- åŸºäºJSON Schema çš„é…ç½®æ–‡ä»¶ã€‚
- æä¾› æ¥å£æ¥å…¥æ ‡å‡†
- æ¥å£å­—æ®µåˆ°schemaçš„æ˜ å°„è¯­æ³•
- æ”¯æŒtemplate
- æ›´æ–°ç²’åº¦ä»¥pathä¸ºä¾å‡†

![image-20210327163922088](https://technologybook.tech/assets/img/image-20210327163922088.png)





ä¸€ä¸‹æ˜¯éƒ¨åˆ†å®ç°

store æ˜¯åŸºäº Rx çš„æ•°æ®æ§åˆ¶ä¸­å¿ƒ

é€šè¿‡åªæœ‰æœ‰æ•ˆæ›´æ–°æ‰èƒ½è®¾ç½®form

```typescript
export default class Manage<T extends HashObj> implements IManage<T> {
    public $form: Subject<T> = new Subject<T>();
    private _storeForm: T;
    public formData: T;
    private static instance: Manage<any>;
    private readonly isFreeze: boolean = false;
    private haveSetDefault = false;
    public validations: Map<string, IValidation> = new Map<string, IValidation>();
    private engine = new TemplateEngine();

    get storeForm() {
        return this._storeForm;
    }

    set storeForm(data) {
        if (!this.isFreeze) {
            this._storeForm = { ...data };
        }
    }

    get data() {
        return this.formData;
    }
		.....
```



æ›´æ–°ç²’åº¦ä¸ºpath

```typescript
    public notifyByPath = (path: string, changed: HashObj, other?: HashObj): void => {
        console.log('I\'m in ', path, this.formData, this.validations);
        const originPath = other!.path;
        const validation = this.validations.get(originPath);
        const newData = produce(this.formData, draft => {
            set(draft, path, changed);
            if (validation && !isEmptyArray(validation.rules)) {
                const errors = validation.rules.map((validatorName: string) => {
                    let defaultValidatorFunc = Validators?.[validatorName];
                    let validatorFunc = this.actions?.[validatorName];
                    if (typeof validatorFunc === 'function') {
                        return validatorFunc(changed);
                    }
                    if (typeof defaultValidatorFunc === 'function') {
                        return defaultValidatorFunc?.(changed);
                    }

                    throw new Error('invalid validation in' + originPath);
                }).filter(r => r !== ValidationResult.PASS);
                const currentComp = draft.components.find(comp => comp.path === originPath)?.validation;
                if (currentComp) {
                    currentComp.errors = errors;
                    set(draft, originPath + 'components', currentComp);
                }
            }
        });

        this.notify(newData);
    };
```



æ•´ä½“çš„çŠ¶æ€ç»´æŠ¤ä¹Ÿæ˜¯åŸºäºContextã€‚

è¿™æ ·ä¸€ä¸ªåŸºç¡€çš„çŠ¶æ€ç®¡é‡Œå°±å®Œæˆäº†ï¼Œ

æ¥ä¸‹æ¥éœ€è¦æ ¹æ®typeæ¸²æŸ“

```typescript
public buildDataTree(dataStruct: HashObj, components: TAllComponents[]): TAllComponents[] | void {
        if (!Array.isArray(components)) {
            throw new TypeError('ComponentTree->buildDataTree: Wrong Type .Params Must Be Array');
        }
        const newComponents: TAllComponents[] = [];
        for (let i = 0, len = components.length; i < len; i++) {
            const componentItem = components[i];
            if (isUndefined(componentItem)) {
                throw new Error(`buildDataTree: Component Invalid`);
            }

            const { path, type } = componentItem || {};
            const currentVal = get(dataStruct, path);

            if (isUndefined(currentVal)) {
                throw new Error(
                    `buildDataTree: current: wrong path ${path}, components should have corresponding component`,
                );
            }

            if (!isObject(currentVal) || type === FormItemType.CUSTOM) {
                const produceItem = produce(componentItem, draft => {
                    set(draft, 'value', currentVal);
                    this.buildComponentTree(draft);
                });
                newComponents.push(produceItem);
            }
        }
        return newComponents;
    }

    public buildComponentTree(component: TAllComponents, componentConfig?: TComponentConfig) {
        const { type, typeName } = component;
        let componentType: FormItemType | string = type;
        if (type === FormItemType.CUSTOM) {
            if (!typeName) {
                console.error('custom must have typeName');
            }
            componentType = typeName;
        }
        set(component, '$$component', this.components[componentType]);
    }

    public buildTree(schema: ISchema, componentLib: HashType<ReactElement>): TAllComponents[] | void {
        this.setComponents(componentLib);
        const { data, components } = schema;
        if (!data || !components) {
            throw new TypeError('ComponentTree::buildTree: Data Or Component Is Invalid');
        }
        return this.buildDataTree(data, components);
    }
```



ç„¶åæ˜¯validator

validatoræœ¬æ„æ˜¯è¦ç”¨æˆ·è‡ªå·±å»ç¡®å®šå“ªäº›ä¸œè¥¿éœ€è¦è¢«æ ¡éªŒï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰å†™å¾ˆå¤šçš„æ ¡éªŒæ–¹æ³•ï¼Œä»…æä¾›ä¸€ä¸ªåŸºç¡€çš„æ ¡éªŒã€‚

è®¾æƒ³æ˜¯éœ€è¦å°†å…¶æŠ½è±¡ä¸ºä¸€ä¸ªåº“ï¼Œä¸“é—¨ç»´æŠ¤ï¼Œ compoenntä¹Ÿæ˜¯ä¸€æ ·ã€‚

```typescript
import { ValidationResult } from '../../constant';
import { isNullOrUndefined, isEmpty } from '../../utils';


export class Validators {
    public static required = (data: unknown): [ValidationResult.FAIL, string] | ValidationResult.PASS => {
        if (isNullOrUndefined(data) || isEmpty(data)) {
            return [ValidationResult.FAIL, 'ä¸èƒ½ä¸ºç©ºï¼'];
        }
        return ValidationResult.PASS;
    };
}
```

æ”¯æŒæ¨¡ç‰ˆå­—ç¬¦

```typescript
import { HashObj, TTemplateResult } from '../../types/project';
import { get, isFunction, isString, isTotalWord, isUndefined } from "../../utils";
import { safeEval } from './safe-eval';

interface ITemplateEngine<T extends HashObj> {
    execute(tpl: string, data: T, current: any): TTemplateResult|TTemplateResult[];
}
// optimization
interface IExpression<T> {
    analyse(tpl: string, data: T, current: any): TTemplateResult;
}

abstract class TemplateExpression<T extends HashObj = HashObj> implements IExpression<T> {
    static getSymbol(tpl: string) {
        let [anchor, variable] = TemplateEngine.symbolReg.exec(tpl) || [];
        if (!(anchor && variable)) {
            console.error('Input Is Invalid: ' + tpl);
            throw new Error('Input Is Invalid: ' + tpl);
        }
        return [anchor, variable];
    }

    abstract analyse(tpl: string, data: T, current: any): TTemplateResult;
}

class PureExpression extends TemplateExpression {
    analyse(tpl: string): string {
        return tpl;
    }
}

class VariableExpression extends TemplateExpression {
    analyse(tpl: string, data: HashObj, current: any): TTemplateResult {
        let [, code] = TemplateExpression.getSymbol(tpl);
        const action = get(data, ['actions', code]);
        const property = get(data, code);
        return isFunction(action) ? action(current, data) : property;
    }
}

class CalculateExpression extends TemplateExpression {
    analyse(tpl: string, data: HashObj): TTemplateResult {
        let [, code] = TemplateExpression.getSymbol(tpl);
        code = code.replace(TemplateEngine.varReg, (current: string) => {
            let result = get(data, current);
            if (['true', 'false'].includes(current)) {
                return `!!${current}`;
            }
            if (typeof result === 'string') {
                return `"${result}"`;
            }
            return result;
        });
        return safeEval(code) || '';
    }
}

export default class TemplateEngine<T extends HashObj = HashObj> implements ITemplateEngine<T> {
    public static readonly symbolReg: RegExp = /^{{(.+)?}}$/i;
    public static readonly varReg: RegExp = /[A-Za-z.]+(?!["'a-z])/g;

    static isTpl(tpl: string): boolean {
        return TemplateEngine.symbolReg.test(tpl);
    }

    getExpressionHandler(tpl: string, data?: T): TemplateExpression {
        if (!TemplateEngine.isTpl(tpl)) {
            return new PureExpression();
        }

        const [, code] = TemplateExpression.getSymbol(tpl);

        if (isTotalWord(code) && !isUndefined(data)) {
            return new VariableExpression();
        }
        return new CalculateExpression();
    }



    public execute(tpl: string|string[], data: T, current?: any): TTemplateResult|TTemplateResult[] {
        if (isString(tpl)) {
            const handler = this.getExpressionHandler(tpl as string, data);
            return handler.analyse(tpl, data, current);
        }
        return tpl.map(item => {
            const handler = this.getExpressionHandler(item, data);
            return handler.analyse(item, data, current);
        })

    }
}
```



æ”¯æŒä¸€ä¸‹å‡ ç§case

```typescript
describe('template-engine', () => {
  it('should execute code', function() {
    const tpl = '{{a}}';
    const mockData = { a: 100 };
    const tplEngine = new TemplateEngine();
    const result = tplEngine.execute(tpl, mockData);
    expect(result).toEqual(100);
  });

  it('safe eval work', () => {
    const tpl = '1+1';
    const result = safeEval(tpl);
    expect(result).toEqual(2);
  });

  it("safe eval is safe", function() {
    const tpl = "1";
    const result = safeEval(tpl);
    expect(result).toBe(1);
    const tpl1 = "onchange";
    const result1 = safeEval(tpl1);
    expect(result1).toBe(undefined)
  });

  it("safe eval throw error", function() {
    const tpl = "asd///"
    expect(() => safeEval(tpl)).toThrow();
  });

  it("safe eval without window", () => {
    const spy = jest.spyOn(utils, 'isUndefined');
    spy.mockReturnValue(true);
    const tpl = "1";
    expect(() => safeEval(tpl)).toThrow();
    spy.mockRestore();
  })

  it('execute expression should work', function() {
    const tpl = '{{1 + 1}}';
    const tplEngine = new TemplateEngine();
    const result = tplEngine.execute(tpl, {});
    expect(result).toEqual(2);
  });

  it('execute expression with variable should work', function() {
    const tpl = '{{a + 1}}';
    const tplEngine = new TemplateEngine();
    const result = tplEngine.execute(tpl, { a: 100 });
    expect(result).toEqual(101);
  });

  it('execute expression with two variable should work', function() {
    const tpl = '{{a + b}}';
    const tplEngine = new TemplateEngine();
    const result = tplEngine.execute(tpl, { a: 100, b: 200 });
    expect(result).toEqual(300);
  });

  it('ternary operator should work', () => {
    const tpl = '{{a > 100 ? 1 : 2}}';
    const mockData = { a: 100 };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData);
    expect(result).toEqual(2);
    mockData.a = 101;
    result = tplEngine.execute(tpl, mockData);
    expect(result).toEqual(1);
  });

  it('call function should work', () => {
    const tpl = '{{d}}';
    const mockData = { a: { b: { c: 12 } }, actions: {d: (current: any) => current.b.c} };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData, { b: { c: 12 } });
    expect(result).toEqual(12);
  });

  it('call lang api should work', () => {
    const tpl = '{{[a]}}';
    const mockData = {
    a: 1
  };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData, { b: { c: 12 } });
    expect(result).toEqual([1]);
  });

  it('expression list will works', () => {
    const tpl = ["{{a}}"];
    const mockData = {
      a: 1
    };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData, { b: { c: 12 } });
    expect(result).toEqual([1])
  });

  it('compare should work', () => {
    const tpl = '{{a === "a"}}';
    const mockData = {
      a: 'a'
    };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData, { b: { c: 12 } });
    expect(result).toEqual(true);
  });

  it('compare should work', () => {
    const tpl = '{{a.b === "a"}}';
    const mockData = {
      a: {
        b: "a"
      }
    };
    const tplEngine = new TemplateEngine();
    let result = tplEngine.execute(tpl, mockData);
    expect(result).toEqual(true);
  });
});
```



æœ€åæš´éœ²ç»™å¼€å‘è€…ä¸€äº›hooks

ç”¨æ¥åº”å¯¹ä¸åŒçš„åœºæ™¯

```typescript
import { useContext, useEffect, useMemo, useRef } from 'react';
import { IContextParams, SingleContext } from '../core';
import { HashObj, IValidation } from '../types/project';

export function useFormChange<T extends HashObj>(path?: string): [T, (data: T) => void] {
    const formContext = SingleContext.getContext<T>();
    const { state, managerIns } = useContext<IContextParams<T>>(formContext);
    return [state, (changed: HashObj, currentPath?: string) => managerIns.notifyByPath(path || currentPath || '', changed)];
}

export function useManage<T extends HashObj>() {
    const formContext = SingleContext.getContext<T>();
    const { managerIns } = useContext<IContextParams<T>>(formContext);
    return managerIns;
}

export function useValidation<T extends HashObj>(path: string, validation?: IValidation) {
    if (!validation) return;
    const formContext = SingleContext.getContext<T>();
    const { managerIns } = useContext<IContextParams<T>>(formContext);
    useMemo(() => {
        managerIns.registryValidation(path, validation);
    }, []);
}

export function usePrevious<T>(value: T): T|undefined {
    const ref = useRef<T>();
    useEffect(() => {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    return ref.current;
}
```

æ€»ç»“

ä¸€ä¸ªåŸºäºJSON Schema çš„buildformå°±å®Œæˆäº†ï¼Œé€šè¿‡å…¨é‡çš„æ¥æ”¶æ•°æ®ç»Ÿä¸€äº†å¯¹æ¥å£çš„interfaceï¼Œæ¯æ¬¡è¯·æ±‚é€šè¿‡å‚æ•°è¯»å–configæ¸²æŸ“è¡¨å•ï¼Œå†é€šè¿‡è¡¨å•æ¸²æŸ“å®ç°é¢å‘é…ç½®æ¸²æŸ“é¡µé¢ï¼Œç¨³æ­¥çº¿ä¸­ï½ğŸ˜„

